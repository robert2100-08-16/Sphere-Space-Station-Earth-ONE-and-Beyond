name: Selective Publish to PDF

on:
  workflow_run:
    workflows: ["GitBook Style Rename"]
    types:
      - completed
  workflow_dispatch:

jobs:
  selective-publish:
    if: github.actor != 'github-actions[bot]' && (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success')
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_branch || github.ref }}

      - name: Determine publish targets
        id: prep
        run: |
          python - <<'PY'
          import yaml, json, os
          manifest = 'publish.yml' if os.path.exists('publish.yml') else 'publish.yaml'
          with open(manifest, 'r', encoding='utf-8') as f:
              data = yaml.safe_load(f) or {}
          targets = [e for e in data.get('publish', []) if e.get('build')]
          with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as out:
              out.write(f"manifest={manifest}\n")
              out.write(f"targets={json.dumps(targets)}\n")
              out.write(f"should_publish={'true' if targets else 'false'}\n")
          PY

      - name: Set up Python and install dependencies
        if: steps.prep.outputs.should_publish == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies (PyYAML, Pandoc/LaTeX, emoji fonts)
        if: steps.prep.outputs.should_publish == 'true'
        run: |
          pip install pyyaml
          sudo apt-get update
          sudo apt-get install -y pandoc texlive-luatex texlive-fonts-recommended texlive-latex-extra texlive-lang-cjk fonts-dejavu-core wget
          sudo mkdir -p /usr/share/fonts/truetype/openmoji
          sudo wget -O /usr/share/fonts/truetype/openmoji/OpenMoji-black-glyf.ttf \
            https://github.com/hfg-gmuend/openmoji/raw/master/font/OpenMoji-black-glyf/OpenMoji-black-glyf.ttf
          sudo fc-cache -f -v
          wget https://gist.githubusercontent.com/zr-tex8r/a5410ad20ab291c390884b960c900537/raw/latex-emoji.lua -O latex-emoji.lua

      - name: Selective publish & PDF conversion
        if: steps.prep.outputs.should_publish == 'true'
        env:
          MANIFEST: ${{ steps.prep.outputs.manifest }}
          TARGETS: ${{ steps.prep.outputs.targets }}
        run: |
          set -euo pipefail
          mkdir -p publish
          python3 <<'PY'
          import os, subprocess, sys, tempfile, yaml, pathlib, json
          subs = {"₀":"$_0$","₁":"$_1$","₂":"$_2$","₃":"$_3$","₄":"$_4$","₅":"$_5$","₆":"$_6$","₇":"$_7$","₈":"$_8$","₉":"$_9$"}
          def normalize_md(text):
              return "".join(subs.get(ch, ch) for ch in text)
          def get_book_title(folder):
              try:
                  with open("book.json", "r", encoding="utf-8") as f:
                      data = json.load(f)
                  root = data.get("root", "")
                  if root.startswith("./"):
                      root = root[2:]
                  if os.path.normpath(root) == os.path.normpath(folder):
                      return data.get("title")
              except Exception:
                  pass
              return None
          def run_pandoc(md_path, pdf_out, add_toc=False, title=None):
              pathlib.Path(os.path.dirname(pdf_out)).mkdir(parents=True, exist_ok=True)
              cmd = [
                  "pandoc", md_path, "-o", pdf_out,
                  "--pdf-engine", "lualatex",
                  "-V", "mainfont=DejaVu Sans",
                  "-V", "monofont=DejaVu Sans Mono",
                  "-V", "emoji=OpenMoji-black-glyf.ttf",
                  "--lua-filter=latex-emoji.lua",
                  "-M", "emojifont=OpenMoji-black-glyf.ttf",
                  "-M", "color=false",
              ]
              if add_toc:
                  cmd.append("--toc")
              if title:
                  cmd.extend(["-V", f"title={title}"])
              print("→ Pandoc:", " ".join(cmd))
              subprocess.check_call(cmd)
          def convert_file(md_file, pdf_out):
              with open(md_file, "r", encoding="utf-8") as f:
                  content = normalize_md(f.read())
              with tempfile.NamedTemporaryFile("w", suffix=".md", delete=False, encoding="utf-8") as tmp:
                  tmp.write(content)
                  tmp_md = tmp.name
              try:
                  run_pandoc(tmp_md, pdf_out)
              finally:
                  os.unlink(tmp_md)
          def extract_md_paths_from_summary(folder):
              summary_path = os.path.join(folder, "summary.md")
              if not os.path.exists(summary_path):
                  return []
              import re
              paths = []
              with open(summary_path, "r", encoding="utf-8") as f:
                  for line in f:
                      for match in re.findall(r'\(([^)]+\.md)\)', line):
                          if not match.startswith("http://") and not match.startswith("https://"):
                              paths.append(os.path.normpath(os.path.join(folder, match)))
              return paths
          def convert_folder(folder, pdf_out):
              md_files = extract_md_paths_from_summary(folder)
              if not md_files:
                  for root, _, files in os.walk(folder):
                      for fname in sorted(files):
                          if fname.lower().endswith((".md", ".markdown")):
                              full_path = os.path.join(root, fname)
                              if fname.lower() == "readme.md":
                                  md_files.insert(0, full_path)
                              else:
                                  md_files.append(full_path)
              if not md_files:
                  print(f"ℹ No Markdown files in {folder} — skipping PDF.")
                  return
              parts = []
              for path in md_files:
                  with open(path, "r", encoding="utf-8") as f:
                      parts.append(normalize_md(f.read()))
              combined = "\n\n\\newpage\n\n".join(parts)
              with open(os.path.join("publish", "combined.md"), "w", encoding="utf-8") as combined_file:
                  combined_file.write(combined)
              with tempfile.NamedTemporaryFile("w", suffix=".md", delete=False, encoding="utf-8") as tmp:
                  tmp.write(combined)
                  tmp_md = tmp.name
              try:
                  title = get_book_title(folder)
                  run_pandoc(tmp_md, pdf_out, add_toc=True, title=title)
              finally:
                  os.unlink(tmp_md)
          manifest = os.environ["MANIFEST"]
          data = yaml.safe_load(open(manifest, "r", encoding="utf-8")) or {}
          targets = json.loads(os.environ["TARGETS"])
          for entry in targets:
              path = entry.get("path")
              out = entry.get("out")
              typ = entry.get("type")
              pdf_out = os.path.join("publish", out)
              print(f"✔ Building {pdf_out} from {path}")
              if typ == "file":
                  convert_file(path, pdf_out)
              elif typ == "folder":
                  convert_folder(path, pdf_out)
              else:
                  print(f"⚠ Unknown type '{typ}' — skipping.")
              for e in data.get("publish", []):
                  if e.get("path") == path:
                      e["build"] = False
          with open(manifest, "w", encoding="utf-8") as f:
              yaml.safe_dump(data, f, sort_keys=False, allow_unicode=True)
          PY

      - name: Commit and push generated PDFs
        if: steps.prep.outputs.should_publish == 'true'
        env:
          MANIFEST: ${{ steps.prep.outputs.manifest }}
        run: |
          if [ -n "$(git status --porcelain publish $MANIFEST)" ]; then
            git config user.name  "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add publish "$MANIFEST"
            git commit -m "chore: selective publish → PDF (auto)"
            git pull --rebase origin "${GITHUB_REF_NAME}"
            git push origin HEAD:"${GITHUB_REF_NAME}"
          else
            echo "No changes in publish or manifest — nothing to commit."
          fi
