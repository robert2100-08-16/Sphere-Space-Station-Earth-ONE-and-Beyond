name: Selective Publish to PDF

on:
  workflow_run:
    workflows: ["GitBook Style Rename"]
    types:
      - completed
  workflow_dispatch:

jobs:
  selective-publish:
    if: github.actor != 'github-actions[bot]' && (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success')
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_branch || github.ref }}

      - name: Get changed files and check manifest relevance
        id: precheck
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            BEFORE="${{ github.event.workflow_run.head_sha }}"
          else
            BEFORE="$(git rev-parse HEAD^ || echo '')"
          fi
          SHA="$(git rev-parse HEAD)"
          echo "before=$BEFORE" >> "$GITHUB_OUTPUT"
          echo "sha=$SHA" >> "$GITHUB_OUTPUT"
          echo "Comparing $BEFORE -> $SHA"
          CHANGED_FILES=$(git diff --name-only "$BEFORE" "$SHA")

          # determine GitBook root from book.json (if available) without Python
          BOOK_ROOT="$(grep -o '"root"[[:space:]]*:[[:space:]]*"[^"]*"' book.json 2>/dev/null | head -n1 | sed -E 's/.*:"([^"]*)"/\1/' | sed 's#^\./##')"
          if [[ -n "$BOOK_ROOT" && "$BOOK_ROOT" != "." ]]; then
            if ! grep -q "^$BOOK_ROOT/" <<<"$CHANGED_FILES"; then
              echo "ℹ No changes detected in $BOOK_ROOT — exiting early."
              echo "should_publish=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

          # Find manifest
          if [[ -f publish.yaml ]]; then
            MANIFEST="publish.yaml"
          elif [[ -f publish.yml ]]; then
            MANIFEST="publish.yml"
          else
            echo "❌ No publish.yaml or publish.yml found in repo."
            exit 1
          fi
          echo "manifest=$MANIFEST" >> "$GITHUB_OUTPUT"
          echo "✓ Manifest found: $MANIFEST"
          echo "Changed files:\n$CHANGED_FILES"

          NEED_PUBLISH=false
          MAP_PATHS=$(awk -F': ' '/^- *path:/ {print $2}' "$MANIFEST")
          for PATH in $MAP_PATHS; do
            if grep -qE "^${PATH}(/|$)" <<<"$CHANGED_FILES"; then
              NEED_PUBLISH=true
              break
            fi
          done
          if [[ "$NEED_PUBLISH" != "true" ]]; then
            echo "ℹ No relevant changes detected — exiting early."
            echo "should_publish=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "should_publish=true" >> "$GITHUB_OUTPUT"

      - name: Set up Python and install dependencies
        if: steps.precheck.outputs.should_publish == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies (PyYAML, Pandoc/LaTeX, emoji fonts)
        if: steps.precheck.outputs.should_publish == 'true'
        run: |
          pip install pyyaml
          sudo apt-get update
          sudo apt-get install -y pandoc texlive-luatex texlive-fonts-recommended texlive-latex-extra texlive-lang-cjk fonts-dejavu-core wget
          sudo mkdir -p /usr/share/fonts/truetype/openmoji
          sudo wget -O /usr/share/fonts/truetype/openmoji/OpenMoji-black-glyf.ttf \
            https://github.com/hfg-gmuend/openmoji/raw/master/font/OpenMoji-black-glyf/OpenMoji-black-glyf.ttf
          sudo fc-cache -f -v
          wget https://gist.githubusercontent.com/zr-tex8r/a5410ad20ab291c390884b960c900537/raw/latex-emoji.lua -O latex-emoji.lua

      - name: Selective publish & PDF conversion
        if: steps.precheck.outputs.should_publish == 'true'
        env:
          MANIFEST: ${{ steps.precheck.outputs.manifest }}
          BEFORE: ${{ steps.precheck.outputs.before }}
          GITHUB_SHA: ${{ steps.precheck.outputs.sha }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p publish
          python3 <<'PY'
          import os, subprocess, sys, tempfile, yaml, pathlib, json

          subs = {"₀":"$_0$","₁":"$_1$","₂":"$_2$","₃":"$_3$","₄":"$_4$",
                  "₅":"$_5$","₆":"$_6$","₇":"$_7$","₈":"$_8$","₉":"$_9$"}

          def normalize_md(text):
              return "".join(subs.get(ch, ch) for ch in text)

          def get_book_title(folder):
              try:
                  with open("book.json", "r", encoding="utf-8") as f:
                      data = json.load(f)
                  root = data.get("root", "")
                  if root.startswith("./"):
                      root = root[2:]
                  if os.path.normpath(root) == os.path.normpath(folder):
                      return data.get("title")
              except Exception:
                  pass
              return None

          def run_pandoc(md_path, pdf_out, add_toc=False, title=None):
              pathlib.Path(os.path.dirname(pdf_out)).mkdir(parents=True, exist_ok=True)
              cmd = [
                  "pandoc", md_path, "-o", pdf_out,
                  "--pdf-engine", "lualatex",
                  "-V", "mainfont=DejaVu Sans",
                  "-V", "monofont=DejaVu Sans Mono",
                  "-V", "emoji=OpenMoji-black-glyf.ttf",
                  "--lua-filter=latex-emoji.lua",
                  "-M", "emojifont=OpenMoji-black-glyf.ttf",
                  "-M", "color=false",
              ]
              if add_toc:
                  cmd.append("--toc")
              if title:
                  cmd.extend(["-V", f"title={title}"])
              print("→ Pandoc:", " ".join(cmd))
              subprocess.check_call(cmd)

          def convert_file(md_file, pdf_out):
              with open(md_file, "r", encoding="utf-8") as f:
                  content = normalize_md(f.read())
              with tempfile.NamedTemporaryFile("w", suffix=".md", delete=False, encoding="utf-8") as tmp:
                  tmp.write(content)
                  tmp_md = tmp.name
              try:
                  run_pandoc(tmp_md, pdf_out)
              finally:
                  os.unlink(tmp_md)

          def extract_md_paths_from_summary(folder):
              summary_path = os.path.join(folder, "summary.md")
              if not os.path.exists(summary_path):
                  return []
              import re
              paths = []
              with open(summary_path, "r", encoding="utf-8") as f:
                  for line in f:
                      for match in re.findall(r'\(([^)]+\.md)\)', line):
                          if not match.startswith("http://") and not match.startswith("https://"):
                              paths.append(os.path.normpath(os.path.join(folder, match)))
              return paths

          def convert_folder(folder, pdf_out):
              md_files = extract_md_paths_from_summary(folder)
              if not md_files:
                  for root, _, files in os.walk(folder):
                      for fname in sorted(files):
                          if fname.lower().endswith((".md", ".markdown")):
                              full_path = os.path.join(root, fname)
                              if fname.lower() == "readme.md":
                                  md_files.insert(0, full_path)
                              else:
                                  md_files.append(full_path)
              if not md_files:
                  print(f"ℹ No Markdown files in {folder} — skipping PDF.")
                  return
              parts = []
              for path in md_files:
                  with open(path, "r", encoding="utf-8") as f:
                      parts.append(normalize_md(f.read()))
              combined = "\n\n\\newpage\n\n".join(parts)
              with open(os.path.join("publish", "combined.md"), "w", encoding="utf-8") as combined_file:
                  combined_file.write(combined)
              with tempfile.NamedTemporaryFile("w", suffix=".md", delete=False, encoding="utf-8") as tmp:
                  tmp.write(combined)
                  tmp_md = tmp.name
              try:
                  title = get_book_title(folder)
                  run_pandoc(tmp_md, pdf_out, add_toc=True, title=title)
              finally:
                  os.unlink(tmp_md)

          BEFORE = os.environ["BEFORE"]
          SHA = os.environ["GITHUB_SHA"]
          changed_files = os.popen(f"git diff --name-only {BEFORE} {SHA}").read().splitlines()
          with open(os.environ["MANIFEST"], "r", encoding="utf-8") as f:
              entries = yaml.safe_load(f).get("publish", [])

          for entry in entries:
              path = entry.get("path")
              out  = entry.get("out")
              typ  = entry.get("type")
              if any(cf == path or cf.startswith(f"{path}/") for cf in changed_files):
                  pdf_out = os.path.join("publish", out)
                  print(f"✔ Changes in {path} → creating {pdf_out}")
                  if typ == "file":
                      convert_file(path, pdf_out)
                  elif typ == "folder":
                      convert_folder(path, pdf_out)
                  else:
                      print(f"⚠ Unknown type '{typ}' — skipping.")
              else:
                  print(f"ℹ No changes in {path} → skipping.")
          PY

      - name: Commit and push generated PDFs
        if: steps.precheck.outputs.should_publish == 'true'
        shell: bash
        run: |
          if [[ -n "$(git status --porcelain publish)" ]]; then
            git config user.name  "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add publish
            git commit -m "chore: selective publish → PDF (auto)"
            git pull --rebase origin "${GITHUB_REF_NAME}"
            git push origin HEAD:"${GITHUB_REF_NAME}"
          else
            echo "No changes in /publish — nothing to commit."
          fi
